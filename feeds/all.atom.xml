<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>It's automatic!</title><link href="https://automaticdavid.github.io/" rel="alternate"></link><link href="https://automaticdavid.github.io/feeds/all.atom.xml" rel="self"></link><id>https://automaticdavid.github.io/</id><updated>2020-06-05T00:00:00+02:00</updated><entry><title>Interop Ansible &amp; Cisco NSO</title><link href="https://automaticdavid.github.io/nso-06-2020.html" rel="alternate"></link><published>2020-06-05T00:00:00+02:00</published><updated>2020-06-05T00:00:00+02:00</updated><author><name>@automaticdavid</name></author><id>tag:automaticdavid.github.io,2020-06-05:/nso-06-2020.html</id><summary type="html">&lt;p&gt;Ansible is a powerful solution to manage network infrastructure. But sometimes there's already a &lt;a href="https://www.cisco.com/c/en/us/solutions/service-provider/solutions-cloud-providers/network-services-orchestrator-solutions.html"&gt;Cisco NSO&lt;/a&gt; setup. The Ansible modules for NSO allow using the two solutions side by side, automating NSO with Ansible. &lt;/p&gt;
&lt;p&gt;The code is available at:&lt;br&gt;
&lt;a href="https://github.com/automaticdavid/ansible-nso"&gt;https://github.com/automaticdavid/ansible-nso&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This can be tested using the …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Ansible is a powerful solution to manage network infrastructure. But sometimes there's already a &lt;a href="https://www.cisco.com/c/en/us/solutions/service-provider/solutions-cloud-providers/network-services-orchestrator-solutions.html"&gt;Cisco NSO&lt;/a&gt; setup. The Ansible modules for NSO allow using the two solutions side by side, automating NSO with Ansible. &lt;/p&gt;
&lt;p&gt;The code is available at:&lt;br&gt;
&lt;a href="https://github.com/automaticdavid/ansible-nso"&gt;https://github.com/automaticdavid/ansible-nso&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This can be tested using the Cisco labs:&lt;br&gt;
&lt;a href="https://devnetsandbox.cisco.com/RM/Topology"&gt;https://devnetsandbox.cisco.com/RM/Topology&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;1- Sync NSO&lt;/h2&gt;
&lt;p&gt;&lt;img alt="NSO" src="https://automaticdavid.github.io/images/nso1.gif"&gt;&lt;/p&gt;
&lt;p&gt;In this first part we start by executing the &lt;code&gt;check_sync.yml&lt;/code&gt; playbook which verifies if the network devices are in sync with the NSO database. It's an example of using the &lt;code&gt;nso_action&lt;/code&gt; Ansible module. We're using it to check the sync status of a given switch, then we check the status for all the devices. &lt;/p&gt;
&lt;p&gt;Then I run the &lt;code&gt;show_address.yml&lt;/code&gt; playbook: it's an example of using the  &lt;code&gt;nso_query&lt;/code&gt; module to run an XPATH query against NSO. I use it to display the names and IP address of my devices.&lt;/p&gt;
&lt;p&gt;I then telnet into one switch (the whole cisco lab is telnet only) and make a manual confiugration change. When I run  &lt;code&gt;check_sync.yml&lt;/code&gt; again, I see that the device is "out-of-sync". With Ansible it becomes easy to deal with such an exception: we could automatically open a ticket in an ITSM system, or trigger a remediation action. &lt;/p&gt;
&lt;p&gt;This remediation could be the next playbook: &lt;code&gt;sync_to.yml&lt;/code&gt;, which executes a sync-to NSO action. This updates the switch configuration with what's defined in the NSO configuration, discarding the manual change. When I run &lt;code&gt;check_sync.yml&lt;/code&gt; again, everything is in sync. &lt;/p&gt;
&lt;h2&gt;2- Using NSO as a Source Of Truth&lt;/h2&gt;
&lt;p&gt;&lt;img alt="NSO" src="https://automaticdavid.github.io/images/nso2.gif"&gt;&lt;/p&gt;
&lt;p&gt;We start with a playbook that uses the &lt;code&gt;nso_verify&lt;/code&gt; Ansible module to perform a backup of the NSO config. We get a local directory with YAML files describing the configuration of each device. Since it's YAML we could store this in git and start managing all our configs as code.  &lt;/p&gt;
&lt;p&gt;To show how this would look like, I change the config of a device by modifying its YAML file. I then run the &lt;code&gt;apply_sot.yml&lt;/code&gt; playbook. The first task reads the data from our local "source of truth" and applies it to the NSO config using the &lt;code&gt;nso_config&lt;/code&gt; module. We then use the &lt;code&gt;nso_verify&lt;/code&gt; module and it shows there is indeed a configuration violation between the NSO config and what is actually defined on the switch: &lt;/p&gt;
&lt;p&gt;&lt;img alt="NSO" src="https://automaticdavid.github.io/images/nso3.png"&gt;&lt;/p&gt;
&lt;p&gt;The playbook follows with a task called "Apply SOT" that executes a sync-to, in order to push the NSO config to the device. We then run one last "Check sync" to confirm that everything is now in sync. &lt;/p&gt;
&lt;p&gt;It is also possible to verify a specific configuration element, as show in the &lt;code&gt;verify_config.yml&lt;/code&gt; playbook. We just check a subset of the NSO config. It can be usefull, for example to check for something across many devices. &lt;/p&gt;
&lt;p&gt;We then run the &lt;code&gt;apply_sot.yml&lt;/code&gt; playbook a second time: nothing happens and "changed" is at 0. That's because the playbook is indempotent and Ansible doesn't do anything when there's nothing to do. Combined with the use of &lt;code&gt;--check-mode&lt;/code&gt; this can be used to check for the compliance of the NSO config. &lt;/p&gt;
&lt;p&gt;Finaly I telnet into the device to show that the change we made in the source of truth was indeed pushed to the physical device. &lt;/p&gt;
&lt;h2&gt;3- Ansible Resource Modules &amp;amp; NSO&lt;/h2&gt;
&lt;p&gt;&lt;img alt="NSO" src="https://automaticdavid.github.io/images/nso4.gif"&gt;&lt;/p&gt;
&lt;p&gt;Here we use one of the many Ansible network modules to change the config of an NXOS device directly, without using NSO. To use Ansible, I enabled ssh on one of the lab's equipement and created an Ansible inventory file. We then use the &lt;code&gt;nxos_vlan&lt;/code&gt; module: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;- name: Direct device change&lt;/span&gt;
&lt;span class="err"&gt;  nxos_vlans:&lt;/span&gt;
&lt;span class="err"&gt;    config:&lt;/span&gt;
&lt;span class="err"&gt;      - vlan_id: 501&lt;/span&gt;
&lt;span class="err"&gt;        name: ansible&lt;/span&gt;
&lt;span class="err"&gt;    state:  merged&lt;/span&gt;
&lt;span class="err"&gt;  register: r_vlan&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Using Ansible's native network modules to automate the network can be easier than through NSO. Here we see that the module shows the "before" and "after" states for the change. &lt;/p&gt;
&lt;p&gt;We then use &lt;code&gt;nso_verify&lt;/code&gt; which shows a violations since NSO is now out of sync. Finally we run a sync_from to push the changed we made with Ansible into the NSO config. &lt;/p&gt;</content><category term="Ansible"></category></entry><entry><title>Interop Ansible &amp; Cisco NSO</title><link href="https://automaticdavid.github.io/nso-06-2020-fr.html" rel="alternate"></link><published>2020-06-05T00:00:00+02:00</published><updated>2020-06-05T00:00:00+02:00</updated><author><name>@automaticdavid</name></author><id>tag:automaticdavid.github.io,2020-06-05:/nso-06-2020-fr.html</id><summary type="html">&lt;p&gt;Ansible est très performant pour automatiser les équipements réseau. Mais parfois on a déjà une infra &lt;a href="https://www.cisco.com/c/en/us/solutions/service-provider/solutions-cloud-providers/network-services-orchestrator-solutions.html"&gt;Cisco NSO&lt;/a&gt; en place. Les modules Ansible pour NSO permettent d'utiliser les deux solutions en cote à cote, de passer de l'une à l'autre de façon simple et finalement de rendre NSO plus interessant …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Ansible est très performant pour automatiser les équipements réseau. Mais parfois on a déjà une infra &lt;a href="https://www.cisco.com/c/en/us/solutions/service-provider/solutions-cloud-providers/network-services-orchestrator-solutions.html"&gt;Cisco NSO&lt;/a&gt; en place. Les modules Ansible pour NSO permettent d'utiliser les deux solutions en cote à cote, de passer de l'une à l'autre de façon simple et finalement de rendre NSO plus interessant.&lt;/p&gt;
&lt;p&gt;Le code utilisé est à:&lt;br&gt;
&lt;a href="https://github.com/automaticdavid/ansible-nso"&gt;https://github.com/automaticdavid/ansible-nso&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Vous pouvez facilement tester en utilisant le lab NSO proposé par Cisco:&lt;br&gt;
&lt;a href="https://devnetsandbox.cisco.com/RM/Topology"&gt;https://devnetsandbox.cisco.com/RM/Topology&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;1- Piloter le sync NSO&lt;/h2&gt;
&lt;p&gt;&lt;img alt="NSO" src="https://automaticdavid.github.io/images/nso1.gif"&gt;&lt;/p&gt;
&lt;p&gt;Dans cette première partie on commence par executer le playbook &lt;code&gt;check_sync.yml&lt;/code&gt; qui permet de vérifier que les switches présents dans l'infra sont synchronisés avec la base NSO. C'est un exemple d'utilisation du module ansible &lt;code&gt;nso_action&lt;/code&gt; qui permet de déclencher des actions NSO. On l'execute d'abord pour un switch nommé et ensuite on check le sync pour tous les equipements. &lt;/p&gt;
&lt;p&gt;Ensuite j'exécute le playbook &lt;code&gt;show_address.yml&lt;/code&gt;: c'est un exemple d'utilisation du module &lt;code&gt;nso_query&lt;/code&gt; qui permet de faire une requête XPATH contre NSO, et que j'utilise pour afficher les IP des mes équipements. &lt;/p&gt;
&lt;p&gt;Je me connecte ensuite à un switch et je modifie la configuration en direct (le lab Cisco est configuré avec seulement telnet). Exécuter de nouveau &lt;code&gt;check_sync.yml&lt;/code&gt; montre alors que l'équipement en question est "out-of-sync". Il devient facile de gérer cette exception dans un playbook, en ouvrant un tiquet dans un ITSM par exemple ou en déclenchant une action de remédiation. &lt;/p&gt;
&lt;p&gt;Cette action peut être par exemple le playbook &lt;code&gt;sync_to.yml&lt;/code&gt; que j'exécute ensuite, qui effectue un sync-to NSO: il pousse la configuration NSO vers le switch. J'exécute ensuite le &lt;code&gt;check_sync.yml&lt;/code&gt; de nouveau pour vérifier que tout est synchrone. &lt;/p&gt;
&lt;h2&gt;2- Source Of Truth avec NSO&lt;/h2&gt;
&lt;p&gt;&lt;img alt="NSO" src="https://automaticdavid.github.io/images/nso2.gif"&gt;&lt;/p&gt;
&lt;p&gt;Dans cette deuxième étape on commence par utiliser le module &lt;code&gt;nso_verify&lt;/code&gt; pour effectuer un backup de la conf NSO. Ce qu'on obtient c'est une copie local des config des équipements, sous forme de YAML. On peut donc utiliser ces fichier comme "source de vérité" de l'infrastructure, en la stockant dans git par exemple. &lt;/p&gt;
&lt;p&gt;Je continue en modifiant une information de configuration pour un des équipements dans son fichier de description. J'exécute ensuite le playbook &lt;code&gt;apply_sot.yml&lt;/code&gt;. La première tache lit les infos de la "source of truth" et les applique à la configuration NSO en utilisant le module &lt;code&gt;nso_config&lt;/code&gt;. On fait ensuite un &lt;code&gt;nso_verify&lt;/code&gt; qui montre qu'il y a bien une violation correspondant à la modification que nous avons effectué, c'est à dire que l'équipement n'est pas synchro avec la config NSO:&lt;/p&gt;
&lt;p&gt;&lt;img alt="NSO" src="https://automaticdavid.github.io/images/nso3.png"&gt;&lt;/p&gt;
&lt;p&gt;On effectue donc un sync-to dans la tache "Apply SOT" et un dernier "Check sync" confirme que l'équipement a été synchronisé avec la source de verité. &lt;/p&gt;
&lt;p&gt;On peut aussi vérifier un élément de configuration en particulier, c'est ce que montre le playbook &lt;code&gt;verify_config.yml&lt;/code&gt;: on vérifie juste un sous ensemble de la config NSO. Cela peut être interessant par exemple si on veut vérifier un même élément de config mais sur un très grand nombre d'équipements. &lt;/p&gt;
&lt;p&gt;Enfin j'exécute le playbook &lt;code&gt;apply_sot.yml&lt;/code&gt; une seconde fois: il ne se passe rien et "changed" est à 0. En effet, le playbook est indempotent et Ansible ne fait rien s'il n'y a rien à faire. Avec &lt;code&gt;--check-mode&lt;/code&gt; cela permet de vérifier facilement la conformité de la config NSO. &lt;/p&gt;
&lt;p&gt;Pour finir je me connecte à l'équipement pour vérifier que la modification faite dans la source of truth a bien été appliquée.&lt;/p&gt;
&lt;h2&gt;3- Resource Modules Ansible &amp;amp; NSO&lt;/h2&gt;
&lt;p&gt;&lt;img alt="NSO" src="https://automaticdavid.github.io/images/nso4.gif"&gt;&lt;/p&gt;
&lt;p&gt;Dans cette dernière partie, on utilise un des modules réseau d'Ansible pour changer la config NXOS directement sur le switch. Pour utiliser Ansible, j'ai activé ssh sur un des équipement et créé un fichier inventory. Le module utilisé est &lt;code&gt;nxos_vlan&lt;/code&gt;: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;- name: Direct device change&lt;/span&gt;
&lt;span class="err"&gt;  nxos_vlans:&lt;/span&gt;
&lt;span class="err"&gt;    config:&lt;/span&gt;
&lt;span class="err"&gt;      - vlan_id: 501&lt;/span&gt;
&lt;span class="err"&gt;        name: ansible&lt;/span&gt;
&lt;span class="err"&gt;    state:  merged&lt;/span&gt;
&lt;span class="err"&gt;  register: r_vlan&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;On voit que le module remonte les états "before" et "after" pour le changement. &lt;/p&gt;
&lt;p&gt;Manipuler les conf des équipements réseau avec Ansible peut être plus simple qu'avec NSO. &lt;/p&gt;
&lt;p&gt;Après le changement, on effectue une vérification de la synchro NSO: évidemment il y a une violation. Le playbook effectue alors un sync_from pour resynchroniser NSO depuis la configuration de l'équipement. On est donc capable d'utiliser NSO depuis Ansible, mais aussi Ansible et NSO en "cote à cote".&lt;/p&gt;</content><category term="Ansible"></category></entry><entry><title>Using Ansible to manage ios devices</title><link href="https://automaticdavid.github.io/webinar-05-2020.html" rel="alternate"></link><published>2020-05-15T00:00:00+02:00</published><updated>2020-05-15T00:00:00+02:00</updated><author><name>@automaticdavid</name></author><id>tag:automaticdavid.github.io,2020-05-15:/webinar-05-2020.html</id><summary type="html">&lt;p&gt;Here's a small write up on the demo I did for our "Beyond Linux, Automate all the things" webinar.&lt;/p&gt;
&lt;p&gt;The code I used is at:&lt;br&gt;
&lt;a href="https://github.com/automaticdavid/webinar_052020"&gt;https://github.com/automaticdavid/webinar_052020&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The security workshop can be accessed at:&lt;br&gt;
&lt;a href="https://ansible.github.io/workshops/"&gt;https://ansible.github.io/workshops/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The webinar replay (in french) is at:&lt;br&gt;
&lt;a href="https://www.redhat.com/en/events/webinar/red-hat-ansible-automation-platform-cloud-reseau-iot-lautomatisation-au-dela-des-systemes-linux"&gt;L …&lt;/a&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;Here's a small write up on the demo I did for our "Beyond Linux, Automate all the things" webinar.&lt;/p&gt;
&lt;p&gt;The code I used is at:&lt;br&gt;
&lt;a href="https://github.com/automaticdavid/webinar_052020"&gt;https://github.com/automaticdavid/webinar_052020&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The security workshop can be accessed at:&lt;br&gt;
&lt;a href="https://ansible.github.io/workshops/"&gt;https://ansible.github.io/workshops/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The webinar replay (in french) is at:&lt;br&gt;
&lt;a href="https://www.redhat.com/en/events/webinar/red-hat-ansible-automation-platform-cloud-reseau-iot-lautomatisation-au-dela-des-systemes-linux"&gt;L’automatisation au delà des systèmes Linux&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;1- Using facts &amp;amp; ios_command&lt;/h2&gt;
&lt;p&gt;&lt;img alt="webinar1_demo_1" src="https://automaticdavid.github.io/images/webinar1_demo_1.gif"&gt;&lt;/p&gt;
&lt;p&gt;In this first part I showed the inventory used and how we can use inventory groups. In the &lt;code&gt;gather_ios_data.yml&lt;/code&gt; playbook, note that I'm using &lt;code&gt;gather_facts: yes&lt;/code&gt; for network devices which is new with Ansible 2.9. This allows me to use the &lt;code&gt;ansible_net_*&lt;/code&gt; variables directly in my play!&lt;/p&gt;
&lt;p&gt;I then show how to use &lt;code&gt;ios_command&lt;/code&gt; to run commands and register the output. I use this to diplay snmp settings on my 4 routers.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;config_routers.yml&lt;/code&gt; playbook allows me to change those snmp settings. Note that when I run it 2 times, the second time does nothing: &lt;code&gt;changed=0&lt;/code&gt; is displayed and all the nodes are green OK. That's &lt;strong&gt;indempotency&lt;/strong&gt;: Ansible doesn't do anything if we're already in the state we want. &lt;/p&gt;
&lt;p&gt;I then log on to the device rtr1 and make a manual change. When I run the playbook again, Ansible corrects that one thing only.&lt;/p&gt;
&lt;h2&gt;2- Ressource modules &amp;amp; Source of truth.&lt;/h2&gt;
&lt;p&gt;&lt;img alt="webinar1_demo_2" src="https://automaticdavid.github.io/images/webinar1_demo_2.gif"&gt;&lt;/p&gt;
&lt;p&gt;To take this a bit further, I then use the &lt;code&gt;ios_facts&lt;/code&gt; modules, and with Ansible 2.9 this comes with a powerfull feature: Ansible is able to extract information from my already configured devices and produce structured data. This is shown when I execute &lt;code&gt;gather_ios_resource.yml&lt;/code&gt; and display the L3 interfaces configuration as a YAML list of interfaces:&lt;/p&gt;
&lt;p&gt;&lt;img alt="webinar1_demo_2" src="https://automaticdavid.github.io/images/webinar1_demo2_list.png"&gt;&lt;/p&gt;
&lt;p&gt;Each list element (starting with a dash) is a dictionnary that contains keys: in the example "ipv4" and "name". The "ipv4" key contains a list, here with only one element. This element is also a dictionary, with only one key: "address".&lt;br&gt;
This makes it very easy to read and modify configuration values. &lt;/p&gt;
&lt;p&gt;As a matter of fact the playbook also writes these values in a &lt;code&gt;host_vars&lt;/code&gt; directory. In the demo I then make a change in these values and run the &lt;code&gt;config_l3.yml&lt;/code&gt; playbook in check mode first: this tells us what Ansible would change but doesn't actually change anything. Then I apply the change by running in normal mode. When I run the &lt;code&gt;gather_ios_resource.yml&lt;/code&gt; again, I can see that the change was made on rtr1. The local source of truth is not updated: it's already up to date.  &lt;/p&gt;
&lt;p&gt;What we see here is that Ansible is able to produce structured configuration data (with the &lt;code&gt;ios_facts&lt;/code&gt; module) and then consume this data to apply configuration changes (with the &lt;code&gt;ios_l3_interfaces&lt;/code&gt; module). Since the configuration is in YAML, it can be managed as code in git, with the inventory itself. This means that you have full tracability of changes, you can re-apply any version of your infrastrcture or manage it with a gitflow. &lt;/p&gt;
&lt;p&gt;As always with Ansible, it starts with some very simple concepts but delivers powerfull ways of doing things. &lt;/p&gt;
&lt;p&gt;Find out more about ressource modules in this Ansible Automates talk by &lt;a href="https://twitter.com/ipvsean?lang=en"&gt;@IPvSean&lt;/a&gt;:&lt;br&gt;
&lt;a href="https://www.ansible.com/2019-ansible-network-automation-resource-modules"&gt;https://www.ansible.com/2019-ansible-network-automation-resource-modules&lt;/a&gt; &lt;/p&gt;</content><category term="Ansible"></category></entry><entry><title>Gérer des équipments IOS avec Ansible</title><link href="https://automaticdavid.github.io/webinar-05-2020-fr.html" rel="alternate"></link><published>2020-05-15T00:00:00+02:00</published><updated>2020-05-15T00:00:00+02:00</updated><author><name>@automaticdavid</name></author><id>tag:automaticdavid.github.io,2020-05-15:/webinar-05-2020-fr.html</id><summary type="html">&lt;p&gt;Ci dessous un petit résumé de la demo que j'ai effecuté lors de notre dernier webinar Red Hat "Automatiser au dela de Linux".   &lt;/p&gt;
&lt;p&gt;Le code de la demo réseau est à:&lt;br&gt;
&lt;a href="https://github.com/automaticdavid/webinar_052020"&gt;https://github.com/automaticdavid/webinar_052020&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Le workshop sécurité est decrit à: &lt;br&gt;
&lt;a href="https://ansible.github.io/workshops/"&gt;https://ansible.github.io/workshops/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Le replay du …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Ci dessous un petit résumé de la demo que j'ai effecuté lors de notre dernier webinar Red Hat "Automatiser au dela de Linux".   &lt;/p&gt;
&lt;p&gt;Le code de la demo réseau est à:&lt;br&gt;
&lt;a href="https://github.com/automaticdavid/webinar_052020"&gt;https://github.com/automaticdavid/webinar_052020&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Le workshop sécurité est decrit à: &lt;br&gt;
&lt;a href="https://ansible.github.io/workshops/"&gt;https://ansible.github.io/workshops/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Le replay du webinar:&lt;br&gt;
&lt;a href="https://www.redhat.com/en/events/webinar/red-hat-ansible-automation-platform-cloud-reseau-iot-lautomatisation-au-dela-des-systemes-linux"&gt;L’automatisation au delà des systèmes Linux&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;1- Utiliser les facts &amp;amp; ios_command&lt;/h2&gt;
&lt;p&gt;&lt;img alt="webinar1_demo_1" src="https://automaticdavid.github.io/images/webinar1_demo_1.gif"&gt;&lt;/p&gt;
&lt;p&gt;Dans cette première partie on regarde l'inventaire utilisé. Dans le playbook &lt;code&gt;gather_ios_data.yml&lt;/code&gt; j'utilise &lt;code&gt;gather_facts: yes&lt;/code&gt; pour les équipements réseau, ce qui est nouveau avec Ansible 2.9. Cela me permet d'utiliser les variables &lt;code&gt;ansible_net_*&lt;/code&gt; directement. &lt;/p&gt;
&lt;p&gt;Ensuite j'utilise &lt;code&gt;ios_command&lt;/code&gt; pour éxecuter une command IOS et récupérer le résultat, que j'utilise pour afficher la conf snmp des 4 routeurs. &lt;/p&gt;
&lt;p&gt;Le playbook &lt;code&gt;config_routers.yml&lt;/code&gt; permet ensuite de changer cette config snmp. Notez que lors de la 2ème éxecution, Ansible affiche &lt;code&gt;changed=0&lt;/code&gt; et toutes les machines sont en "OK vert". C'est l'indempotence: les equipements sont déjà dans l'état que l'on veut et Ansible ne fait rien quand il n'y a rien à faire.&lt;/p&gt;
&lt;p&gt;Ensuite je me connecte directement à un switch et je fais un changement manuel. Quand j'execute à nouveau mon playbook de config, seul ce changement là est corrigé. &lt;/p&gt;
&lt;h2&gt;2- Resource modules &amp;amp; Source of truth.&lt;/h2&gt;
&lt;p&gt;&lt;img alt="webinar1_demo_2" src="https://automaticdavid.github.io/images/webinar1_demo_2.gif"&gt;&lt;/p&gt;
&lt;p&gt;Pour aller un peu plus loin j'utilise ensuite le module &lt;code&gt;ios_facts&lt;/code&gt; et avec Ansible 2.9 cela permet d'extraire la configuration des swtiches existants sous la forme de données structurées. Quand j'execute le playbook &lt;code&gt;gather_ios_resource.yml&lt;/code&gt; on voit que la configuration des interfaces L3 est affichée sous la forme d'une liste d'interfaces en YAML: &lt;/p&gt;
&lt;p&gt;&lt;img alt="webinar1_demo_2" src="https://automaticdavid.github.io/images/webinar1_demo2_list.png"&gt;&lt;/p&gt;
&lt;p&gt;Chaque élément de la liste (marqué par un tiret) est un dictionnaire qui contient des clés: dans cet exemple "ipv4" et "name". La clé "ipv4" contient une liste, qui ici n'a qu'un seul élément. Cet élément est aussi un dictionaire, qui n'a qu'une seule clé: "address". 
Avec un peu d'habitude cette façon de représenter la configuration permet de lire et modifier les valeurs de façon simple et robuste.&lt;/p&gt;
&lt;p&gt;Le playbook écrit ces valeurs dans le repertoire &lt;code&gt;host_vars&lt;/code&gt;. Dans la demo je change une valeur de configuration dans le fichier qui décrit le routeur rtr1 et j'execute le playbook &lt;code&gt;config_l3.yml&lt;/code&gt; en mode "check". Ce mode fait qu'Ansible dit quels changements il ferait sans vraiment les faire. J'execute ensuite le changement et je vérifie qu'il a bien eu lieu avec le playbook &lt;code&gt;gather_ios_resource.yml&lt;/code&gt;. Ce dernier ne modifie pas la source de verité car elle est deja à jour!&lt;/p&gt;
&lt;p&gt;Ce que cela montre c'est que avec le module &lt;code&gt;ios_facts&lt;/code&gt;, Ansible est capable de produire des données structurées à partir de la configuration existante sur les switchs. Et qu'avec le module  &lt;code&gt;ios_l3_interfaces&lt;/code&gt; on est capable de ré-utiliser ces données directement, pour modifier la configuration des équipements. Comme la configuration est en YAML, on peut la gérer comme du code dans git. Cela signifie qu'on a une traçabilité totale des changements, qu'on peut ré-appliquer n'importe quelle version, ou encore qu'on peut manager l'infrastructure réseau avec un gitflow. &lt;/p&gt;
&lt;p&gt;Plus d'info sur les resources modules dans cette conférence donnée par &lt;a href="https://twitter.com/ipvsean?lang=en"&gt;@IPvSean&lt;/a&gt;:&lt;br&gt;
&lt;a href="https://www.ansible.com/2019-ansible-network-automation-resource-modules"&gt;https://www.ansible.com/2019-ansible-network-automation-resource-modules&lt;/a&gt; &lt;/p&gt;</content><category term="Ansible"></category></entry><entry><title>Personal picks for Summit 2020</title><link href="https://automaticdavid.github.io/personal-picks-for-summit-2020.html" rel="alternate"></link><published>2020-04-20T00:00:00+02:00</published><updated>2020-04-20T00:00:00+02:00</updated><author><name>@automaticdavid</name></author><id>tag:automaticdavid.github.io,2020-04-20:/personal-picks-for-summit-2020.html</id><summary type="html">&lt;p&gt;There's a looooot of sessions at the &lt;a href="https://www.redhat.com/en/summit"&gt;Red Hat Summit 2020&lt;/a&gt; but on the plus side it's a free virtual experience, so register now! I picked the following Automation sessions for myself and thought I would share. All those are CEST times.&lt;br&gt;
You can view the full catalogue at: &lt;a href="https://summit.redhat.com/conference/sessions"&gt;https …&lt;/a&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;There's a looooot of sessions at the &lt;a href="https://www.redhat.com/en/summit"&gt;Red Hat Summit 2020&lt;/a&gt; but on the plus side it's a free virtual experience, so register now! I picked the following Automation sessions for myself and thought I would share. All those are CEST times.&lt;br&gt;
You can view the full catalogue at: &lt;a href="https://summit.redhat.com/conference/sessions"&gt;https://summit.redhat.com/conference/sessions&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;Let's kick off the summit with an evening of roadmaps and long term vision:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Tuesday, April 28, 5:00 p.m.&lt;br&gt;
&lt;strong&gt;Red Hat Ansible Automation Platform overview and roadmap&lt;/strong&gt; &lt;br&gt;
&lt;a href="https://summit.redhat.com/conference/sessions/details/1e449272-5744-4b85-9418-9c621c0836e2?sb=false"&gt;https://summit.redhat.com/conference/sessions/details/1e449272-5744-4b85-9418-9c621c0836e2?sb=false&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Tuesday, April 28, 7:00 p.m.&lt;br&gt;
&lt;strong&gt;Red Hat Management strategy and roadmap&lt;/strong&gt; &lt;br&gt;
&lt;a href="https://summit.redhat.com/conference/sessions/details/8cf6c4c6-f5bd-4c82-bdf2-b3239816c9fc?sb=false"&gt;https://summit.redhat.com/conference/sessions/details/8cf6c4c6-f5bd-4c82-bdf2-b3239816c9fc?sb=false&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Tuesday, April 28, 8:00 p.m. &lt;br&gt;
&lt;strong&gt;Value of an automation platform—more than just the Ansible you know today&lt;/strong&gt; &lt;br&gt;
&lt;a href="https://summit.redhat.com/conference/sessions/details/01a0adff-3130-46f0-9cc4-37fbbe33ae00?sb=false"&gt;https://summit.redhat.com/conference/sessions/details/01a0adff-3130-46f0-9cc4-37fbbe33ae00?sb=false&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;On the next day, let's have an Ansible Breakfast: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Wednesday, April 29, 7:00 a.m. &lt;br&gt;
&lt;strong&gt;What does it take to build, certify and publish Ansible Content Collections?&lt;/strong&gt; &lt;br&gt;
&lt;a href="https://summit.redhat.com/conference/sessions/details/0ead96e4-a706-4842-aff5-941d4621dfe2?sb=false"&gt;https://summit.redhat.com/conference/sessions/details/0ead96e4-a706-4842-aff5-941d4621dfe2?sb=false&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Wednesday, April 29, 10:00 a.m. &lt;br&gt;
&lt;strong&gt;Lights, camera, action—automating broadcast media&lt;/strong&gt; &lt;br&gt;
&lt;a href="https://summit.redhat.com/conference/sessions/details/410a9560-7e10-4d43-8945-238938480a1c?sb=false"&gt;https://summit.redhat.com/conference/sessions/details/410a9560-7e10-4d43-8945-238938480a1c?sb=false&lt;/a&gt; &lt;br&gt;
Or alternatively at the same time slot: &lt;br&gt;
&lt;strong&gt;Optimizing DevSecOps: Visibility &amp;amp; control with IBM &amp;amp; Red Hat&lt;/strong&gt; &lt;br&gt;
&lt;a href="https://summit.redhat.com/conference/sessions/details/eb0e068b-4dee-4d55-b6b2-e4830e11f3ba?sb=false"&gt;https://summit.redhat.com/conference/sessions/details/eb0e068b-4dee-4d55-b6b2-e4830e11f3ba?sb=false&lt;/a&gt;   &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Then for Wednesday afternoon:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Wednesday, April 29, 1:00 p.m. &lt;br&gt;
&lt;strong&gt;3 ways to reduce remediation time to cyberattacks with Ansible security automation&lt;/strong&gt; &lt;br&gt;
&lt;a href="https://summit.redhat.com/conference/sessions/details/91eb9e8a-3422-4e8f-9a28-56cc1632c72e?sb=false"&gt;https://summit.redhat.com/conference/sessions/details/91eb9e8a-3422-4e8f-9a28-56cc1632c72e?sb=false&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Wednesday, April 29, 5:00 p.m. &lt;br&gt;
&lt;strong&gt;Automating Windows in a highly secure environment&lt;/strong&gt; &lt;br&gt;
&lt;a href="https://summit.redhat.com/conference/sessions/details/24f7193a-7fe2-4eb5-9942-05e38a128d3a?sb=false"&gt;https://summit.redhat.com/conference/sessions/details/24f7193a-7fe2-4eb5-9942-05e38a128d3a?sb=false&lt;/a&gt; &lt;br&gt;
Or alternatively at the same time slot: &lt;br&gt;
&lt;strong&gt;Case study: Changing governed IT processes to automation, and reinventing IT Ops as site reliability engineering&lt;/strong&gt; &lt;br&gt;
&lt;a href="https://summit.redhat.com/conference/sessions/details/5272be68-7da0-4ba9-af89-9178c92af69f?sb=false"&gt;https://summit.redhat.com/conference/sessions/details/5272be68-7da0-4ba9-af89-9178c92af69f?sb=false&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can also register for labs where you'll get your own test infra to use in a guided session, for example this one:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Tuesday, April 28, 7:00 p.m.&lt;br&gt;
&lt;strong&gt;Demo of using Red Hat Insights to proactively keep your Red Hat Enterprise Linux environment stable, secure and compliant&lt;/strong&gt;&lt;br&gt;
&lt;a href="https://summit.redhat.com/conference/sessions/details/02f9ba4a-7db6-43c3-9f9f-9f5ea966b48f?sb=false"&gt;https://summit.redhat.com/conference/sessions/details/02f9ba4a-7db6-43c3-9f9f-9f5ea966b48f?sb=false&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;See you (virtually) at the Summit !&lt;/p&gt;</content><category term="Personal"></category></entry><entry><title>Using conditional import of external vars with Tower's Smart Inventories</title><link href="https://automaticdavid.github.io/using-conditional-import-of-external-vars-with-towers-smart-inventories.html" rel="alternate"></link><published>2019-10-20T00:00:00+02:00</published><updated>2019-10-20T00:00:00+02:00</updated><author><name>@automaticdavid</name></author><id>tag:automaticdavid.github.io,2019-10-20:/using-conditional-import-of-external-vars-with-towers-smart-inventories.html</id><summary type="html">&lt;p&gt;The problem we are trying to solve is that smart inventories in Tower do not include groups, and therefore we can't use group_vars defined at the inventories level. Since host_vars are imported we will use a host_var to trigger import of the wanted vars.&lt;/p&gt;
&lt;h2&gt;1- VM Properties&lt;/h2&gt;
&lt;p&gt;We're going to …&lt;/p&gt;</summary><content type="html">&lt;p&gt;The problem we are trying to solve is that smart inventories in Tower do not include groups, and therefore we can't use group_vars defined at the inventories level. Since host_vars are imported we will use a host_var to trigger import of the wanted vars.&lt;/p&gt;
&lt;h2&gt;1- VM Properties&lt;/h2&gt;
&lt;p&gt;We're going to use the "Custom Attributes" feature of vSphere to inherit a host_vars. Each VM has a custom attribute &lt;code&gt;dcl-custom-attr&lt;/code&gt; but with a diferent value for each of our test VMs:&lt;/p&gt;
&lt;p&gt;&lt;img alt="VM Custom prop" src="https://automaticdavid.github.io/images/custom-prop.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="VM Custom prop" src="https://automaticdavid.github.io/images/custom-prop-2.png"&gt;&lt;/p&gt;
&lt;h2&gt;2- Dynamic Inventory &amp;amp; Smart Inventory in Tower&lt;/h2&gt;
&lt;p&gt;We're using the VMware dynamic inventory with source variables: &lt;/p&gt;
&lt;p&gt;&lt;img alt="VM Custom prop" src="https://automaticdavid.github.io/images/inv.png"&gt;&lt;/p&gt;
&lt;p&gt;We want to test importing vars for hosts sourced from a smart inventory so we define a smart inventory:&lt;/p&gt;
&lt;p&gt;&lt;img alt="VM Custom prop" src="https://automaticdavid.github.io/images/smart.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="VM Custom prop" src="https://automaticdavid.github.io/images/smart-hosts.png"&gt;&lt;/p&gt;
&lt;p&gt;The VMs in the smart inventory show the custom attributes as host_vars:&lt;/p&gt;
&lt;p&gt;&lt;img alt="VM Custom prop" src="https://automaticdavid.github.io/images/vars.png"&gt;&lt;/p&gt;
&lt;h2&gt;3- Conditional include of vars&lt;/h2&gt;
&lt;p&gt;Now we can use the following playbook:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="x"&gt;---&lt;/span&gt;
&lt;span class="x"&gt;- name: Conditional vars inclusion based on host_vars &lt;/span&gt;
&lt;span class="x"&gt;  hosts: all&lt;/span&gt;
&lt;span class="x"&gt;  gather_facts: no&lt;/span&gt;

&lt;span class="x"&gt;  tasks:&lt;/span&gt;

&lt;span class="x"&gt;    - name: Extract Custom Prop Value&lt;/span&gt;
&lt;span class="x"&gt;      set_fact:&lt;/span&gt;
&lt;span class="x"&gt;        vm_props: &amp;quot;&lt;/span&gt;&lt;span class="cp"&gt;{{&lt;/span&gt; &lt;span class="nv"&gt;value&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="nf"&gt;map&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;attribute&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;value&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;)|&lt;/span&gt; &lt;span class="nf"&gt;list&lt;/span&gt; &lt;span class="cp"&gt;}}&lt;/span&gt;&lt;span class="x"&gt;&amp;quot;&lt;/span&gt;

&lt;span class="x"&gt;    - name: Include for first group&lt;/span&gt;
&lt;span class="x"&gt;      include_vars:&lt;/span&gt;
&lt;span class="x"&gt;        file: first.yml&lt;/span&gt;
&lt;span class="x"&gt;      when: &amp;#39;&amp;quot;dcl-1&amp;quot; in vm_props&amp;#39;&lt;/span&gt;

&lt;span class="x"&gt;    - name: Include for second group&lt;/span&gt;
&lt;span class="x"&gt;      include_vars:&lt;/span&gt;
&lt;span class="x"&gt;        file: second.yml&lt;/span&gt;
&lt;span class="x"&gt;      when: &amp;#39;&amp;quot;dcl-2&amp;quot; in vm_props&amp;#39;&lt;/span&gt;

&lt;span class="x"&gt;    - name: Display imported value&lt;/span&gt;
&lt;span class="x"&gt;      debug: &lt;/span&gt;
&lt;span class="x"&gt;        msg: &amp;quot;&lt;/span&gt;&lt;span class="cp"&gt;{{&lt;/span&gt; &lt;span class="nv"&gt;my_imported_value&lt;/span&gt; &lt;span class="cp"&gt;}}&lt;/span&gt;&lt;span class="x"&gt;&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Depending on the value of the host_var we include a file or another, that defines the variable &lt;code&gt;my_imported_value&lt;/code&gt; but with different values. &lt;BR&gt;
See: https://github.com/automaticdavid/set_vars&lt;/p&gt;
&lt;p&gt;We define the associated Tower template:&lt;/p&gt;
&lt;p&gt;&lt;img alt="VM Custom prop" src="https://automaticdavid.github.io/images/template.png"&gt;&lt;/p&gt;
&lt;p&gt;Execution yields the inclusion of the var with the correct value for each VM: &lt;/p&gt;
&lt;p&gt;&lt;img alt="VM Custom prop" src="https://automaticdavid.github.io/images/result.png"&gt;&lt;/p&gt;
&lt;p&gt;We can use the same mechanism to include different vars for each VM.&lt;/p&gt;
&lt;p&gt;This could be used in a role that would get included at the begining of each playbook, or with a Tower Workflow. &lt;/p&gt;</content><category term="Tower"></category></entry><entry><title>Configure an SSH proxy for Ansible Tower</title><link href="https://automaticdavid.github.io/configure-an-ssh-proxy-for-ansible-tower.html" rel="alternate"></link><published>2019-04-19T00:00:00+02:00</published><updated>2019-04-19T00:00:00+02:00</updated><author><name>@automaticdavid</name></author><id>tag:automaticdavid.github.io,2019-04-19:/configure-an-ssh-proxy-for-ansible-tower.html</id><summary type="html">&lt;p&gt;In my lab, some of the VMs I provision are only accessible through a jump host. This means Tower needs to connect to the jump host first then to the target VMs in order to run playbooks. &lt;/p&gt;
&lt;p&gt;One way to enable Tower to reach isolated nodes is to use a …&lt;/p&gt;</summary><content type="html">&lt;p&gt;In my lab, some of the VMs I provision are only accessible through a jump host. This means Tower needs to connect to the jump host first then to the target VMs in order to run playbooks. &lt;/p&gt;
&lt;p&gt;One way to enable Tower to reach isolated nodes is to use a dedicated ansible host, that is both accessible by Tower and able to reach the target network. This is called an isolated node and the way to set it up is described at: &lt;a href="http://docs.ansible.com/ansible-tower/latest/html/administration/clustering.html#isolated-instance-groups"&gt;6.3. Isolated Instance Groups&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Isolated nodes will have Ansible installed on them, and sometimes that's not possible on the jump host. But you can also configure Tower to use the jump host as an ssh proxy: Tower will ssh to the jump host and from it access the targets. This is documented at: &lt;a href="http://docs.ansible.com/ansible-tower/latest/html/administration/tipsandtricks.html#setting-up-a-jump-host-to-use-with-tower"&gt;22.6. Setting up a jump host to use with Tower&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;I had some problems getting it to work so decided to document what I did. &lt;/p&gt;
&lt;h3&gt;1. Disable PRoot&lt;/h3&gt;
&lt;p&gt;As described in the "Tower Tips and Tricks" official documentation page.&lt;/p&gt;
&lt;h3&gt;2. Add SSH connection arguments at the inventory level&lt;/h3&gt;
&lt;p&gt;I added the following variables at the inventory level:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;ansible_connection&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;ssh&lt;/span&gt;
&lt;span class="n"&gt;ansible_ssh_common_args&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;-o ProxyCommand=&amp;quot;ssh -W %h:%p -q jump-host-user@jump-host.example.com&amp;quot;&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Defining those at the inventory level means that only the hosts of that inventory will be using the jump host. And it also means you don't have to edit SSH configuration files on the Tower host.&lt;/p&gt;
&lt;h3&gt;3. Add the SSH private key of the jump host to Tower&lt;/h3&gt;
&lt;p&gt;Tower will use it to ssh to the jump host: copy the &lt;code&gt;id_rsa&lt;/code&gt; file of the jump host on the tower host into &lt;code&gt;/var/lib/awx/.ssh/&lt;/code&gt;
Make sure it has the following user, group and permissions:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;-rw-------. 1 awx awx 1679 Apr 30 16:37 id_rsa&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;You can also put the key in another directory and specify its path using the -i switch of the ProxyCommand.&lt;/p&gt;
&lt;h3&gt;4. Add the credentials for the target machine&lt;/h3&gt;
&lt;p&gt;Once connected to the jump host, Tower needs to connect to the target machine. 
I defined a Tower Machine Credential, in my case for the root user (of the target node) using a password to connect.
You can also use an ssh key if your target nodes support it, as with any machine credentials.&lt;/p&gt;
&lt;h3&gt;5. Define the Job Template&lt;/h3&gt;
&lt;p&gt;The tower template needs to have: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The inventory used in 2&lt;/li&gt;
&lt;li&gt;The machine credential defined in 4.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And it works ! Thanks to &lt;a href="https://github.com/victorock"&gt;@victorock&lt;/a&gt; ;)&lt;/p&gt;</content><category term="Tower"></category></entry></feed>